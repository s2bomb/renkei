# Best-of-N Pass E -- Execution-Lead Red Team

Date: 2026-02-26
Lens: adversarial failure-mode analysis of the execution-stage split

This pass assumes the split target is:

- `shaper` -> `tech-lead` -> `execution-lead`
- `execution-lead` delegates to `test-implementer`, `implement-plan`, `validate-plan`
- `architect-opencode` is deprecated over time

Grounding used in this pass:

- Shape Up full corpus, especially building and betting controls (`thoughts/research/Shape-Up-Book/markdown/pages/010-2.1-chapter-07.md`, `thoughts/research/Shape-Up-Book/markdown/pages/011-2.2-chapter-08.md`, `thoughts/research/Shape-Up-Book/markdown/pages/013-3.1-chapter-10.md`, `thoughts/research/Shape-Up-Book/markdown/pages/016-3.4-chapter-13.md`, `thoughts/research/Shape-Up-Book/markdown/pages/017-3.5-chapter-14.md`, `thoughts/research/Shape-Up-Book/markdown/pages/021-4.1-appendix-02.md`)
- Current runtime baseline (`/home/brad/.claude/skills/architect-opencode/SKILL.md`, `/home/brad/.claude/skills/validate-plan/SKILL.md`)
- Renkei derivation/workflow/vocabulary doctrine (`docs/framework/AUTHORING.md`, `docs/framework/ARCHETYPE_WORKFLOW.md`, `docs/framework/VOCABULARY.md`)
- Neighbor contracts (`framework/archetypes/technical-preparation/tech-lead/doctrine/handoff-contract.md`, `framework/archetypes/development/test-implementer/doctrine/output-contract.md`, `framework/archetypes/development/implement-plan/doctrine/output-contract.md`)
- Execution-lead scaffold (`framework/archetypes/execution/execution-lead/design/why.md`, `framework/archetypes/execution/execution-lead/design/team-map.md`)

## 1) Top 5 objections to naive execution-lead design

### Objection 1 -- It can collapse into taskmaster behavior and violate Shape Up's execution autonomy

Shape Up is explicit: assign projects, not tasks (`013-3.1-chapter-10.md`). A naive `execution-lead` with over-prescriptive phase micromanagement recreates the exact anti-pattern Shape Up rejects. If this role starts writing task breakdowns for members instead of enforcing contracts and quality gates, it becomes a scheduler, not a stage owner.

Failure mode:

- the leader decomposes too much, teams stop discovering tasks/scopes through real work
- uphill unknowns are hidden from leadership until too late (`016-3.4-chapter-13.md`)
- "execution discipline" becomes false certainty

Red-team verdict: without explicit anti-taskmaster anti-identity, this role drifts quickly.

### Objection 2 -- Intake is underspecified, so execution starts on unfit packages

Current `tech-lead` handoff contract is stronger than execution scaffold (`tech-lead/doctrine/handoff-contract.md` vs `execution-lead/design/why.md`). If `execution-lead` lacks a hard acceptance gate (receipt, sufficiency, blockers), it will absorb preparation debt and then silently patch upstream defects.

Failure mode:

- coding starts with missing test spec links, unresolved design assumptions, or fuzzy must-have boundaries
- implementation burns cycle time proving package incompleteness
- accountability blurs: was this preparation failure or execution failure?

Red-team verdict: no hard intake gate means stage boundaries are decorative, not operational.

### Objection 3 -- Member contracts are not harmonized; contradictions will produce blame loops

`test-implementer` says tests are red-phase truth standard and separate from implementation commits. `implement-plan` says it must not modify tests if mismatches exist. `validate-plan` checks source coverage and quality, not just pass/fail. Naive execution design can miss these contract differences and issue impossible instructions.

Failure mode:

- implementer edits tests to "make progress" (contract violation)
- validator flags requirement gaps late because no traceability gate was enforced early
- leader oscillates between members with no single defect classification model

Red-team verdict: without explicit cross-member contract matrix, this team deadlocks in "not my ownership" loops.

### Objection 4 -- No circuit-breaker semantics for execution means runaway cycles

Shape Up's key controls are capped downside and hard stop (`011-2.2-chapter-08.md`, `017-3.5-chapter-14.md`). Naive execution-lead designs typically optimize for completion pressure and encourage extending work until it passes. That is anti-Shape-Up.

Failure mode:

- repeated retries across test/implement/validate become implicit scope expansion
- must-have and nice-to-have boundaries erode under schedule pressure
- stage exits with "technically done" but strategically overrun cost

Red-team verdict: if execution-lead lacks explicit stop/re-bet triggers, it reintroduces backlog thinking by stealth.

### Objection 5 -- Migration risk is hand-waved; deprecating architect-opencode can break daily drivability

`architect-opencode` is currently the working runtime orchestrator with proven command semantics. A naive "flip switch" migration to execution-lead before contract parity and observability exists will reduce throughput.

Failure mode:

- delegation prompts regress from known-good pattern
- unresolved edge responsibilities (branch strategy, packaging, escalation framing) disappear or duplicate
- system enters split-brain where both leaders think they own execution loops

Red-team verdict: migration must be staged with shadow validation and rollback criteria, not principle-first cutover.

## 2) Hardened V1 truth/ethos/doctrine recommendation

### V1 Truth (3-5 truths, concrete)

1. Stage boundaries are risk controls, not org chart cosmetics (`tech-lead/truth/stage-boundaries-are-risk-controls.md`).
2. In fixed time, scope is the trade-off lever; uncapped execution is strategic failure (`017-3.5-chapter-14.md`).
3. Execution teams discover real tasks during work; pre-shredded task plans lower outcome quality (`013-3.1-chapter-10.md`, `016-3.4-chapter-13.md`).
4. Validation must verify source requirements, not only plan checkboxes (`/home/brad/.claude/skills/validate-plan/SKILL.md`).
5. Test-first separation is a control mechanism: test-writing and code-writing are distinct authorities (`framework/archetypes/development/test-implementer/ethos/identity.md`, `framework/archetypes/development/implement-plan/ethos/identity.md`).

### V1 Ethos (identity/tenets/principles)

Identity (anti-drift):

- "You are the execution-stage owner. You do not shape product intent, redesign APIs, or write production/test code directly."
- "You are not a taskmaster. You enforce contracts and quality gates while preserving builder autonomy."

Tenets:

1. Acceptance before action -- no package intake, no execution.
2. Contract over convenience -- defects route to owning stage, not patched in-place.
3. Unknowns must be visible -- uphill work is reported, not hidden.
4. Capped downside -- retries and extensions are explicit bets, never default.
5. Evidence over assertion -- stage-complete claims require traceable proof.

Principles:

1. Keep one mental-step therefore-chain from truth to doctrine (Renkei derivation boundary).
2. Prefer deterministic handoff fields over narrative summaries.
3. Escalate decisions, not artifacts.
4. Separate "can continue" from "is complete" gates.

### V1 Doctrine (minimum article behaviors)

Process:

1. Intake gate (acknowledge, accept/reject package, publish blockers)
2. Test phase orchestration (`test-implementer`)
3. Implementation phase orchestration (`implement-plan`)
4. Validation phase orchestration (`validate-plan`)
5. Defect classification and routing (prep defect vs execution defect vs decision block)
6. Circuit-breaker decision (continue, cut scope, re-bet, or stop)

Orchestration:

- Prescribed delegation contracts per member
- Parallelism rules based on file overlap and phase independence
- Mandatory verbatim propagation for key convictions where required

Pipeline:

- Input: execution-ready package from `tech-lead`
- Output: stage-complete execution report + validation evidence + unresolved escalation packet

Output contract:

- one deterministic execution report with required fields (status, coverage map, commit map, unresolved defects, escalation decisions)

## 3) Minimum viable handoff contract from `tech-lead`

The minimum contract should be treated as schema, not prose.

Required fields (all required):

1. `item_id`
2. `workspace_path`
3. `shape_source`
4. `spec_source`
5. `research_sources[]`
6. `api_design_sources[]`
7. `test_spec_source`
8. `plan_source`
9. `must_have_scope[]`
10. `nice_to_have_scope[]`
11. `unresolved_decisions[]` (explicit `none` allowed)
12. `accepted_risks[]` (explicit `none` allowed)
13. `evidence_traceability` (requirement -> artifact references)

Execution-lead acknowledgment (must return atomically):

1. `receipt_confirmed: true|false`
2. `sufficiency_for_execution: true|false`
3. `blocking_gaps[]`
4. `first_execution_step`
5. `owner_of_each_gap[]` (prep/execution/decision)
6. `response_sla` (when next update is due)

Transfer rule:

- Ownership transfers only when `receipt_confirmed=true` and `sufficiency_for_execution=true`.
- Otherwise package is rejected with explicit defects; ownership remains with `tech-lead`.

## 4) Member contract expectations for test-implementer / implement-plan / validate-plan

### `test-implementer` expectations

- Implements test spec faithfully; does not author or reinterpret spec.
- Produces executable test files with separate commits from implementation.
- Failing tests are expected and are the truth standard for next phase.
- If spec gaps appear, raises defect to execution-lead; does not fill with invented requirements.

### `implement-plan` expectations

- Implements plan phases and makes existing tests pass.
- Does not modify test intent/specification to force green.
- One validated commit per phase; verification before commit.
- On mismatch with plan/tests/design, reports precise defect classification upstream.

### `validate-plan` expectations

- Validates against plan and source requirements, not only completion checkboxes.
- Runs verification commands and inspects real code.
- Reports deviations by severity with concrete file evidence.
- Distinguishes: implementation defect, plan defect, missing source coverage.

### Cross-member expectations enforced by execution-lead

1. No role may consume another role's authority boundary.
2. Every defect is tagged with owner and required action.
3. Stage completeness requires all three: passing implementation evidence, source coverage evidence, and explicit unresolved-decision status.

## 5) Migration steps to reduce risk while deprecating architect-opencode

1. Define contract parity matrix.
   - Enumerate every `architect-opencode` execution responsibility (test orchestration, implementation loops, validation, escalation, branch/package guidance).
   - Mark each as: move now, move later, retire.

2. Introduce `execution-lead` in shadow mode.
   - Keep `architect-opencode` as active owner.
   - Run `execution-lead` as observer producing parallel decision logs (no command side effects).
   - Compare divergence for at least several real execution items.

3. Harden intake and member contracts first.
   - Implement the handoff schema above before cutover.
   - Add defect taxonomy and ownership tags to all stage reports.

4. Cut over with rollback trigger.
   - Promote `execution-lead` to active owner only after shadow parity is acceptable.
   - Keep rollback path: if critical regressions occur, route execution back to `architect-opencode` within one item.

5. Decommission in two steps, not one.
   - Step A: remove execution authority from `architect-opencode`, keep read-only advisory references.
   - Step B: remove obsolete doctrine after stable operation period.

6. Add explicit anti-split-brain rule.
   - At runtime, exactly one execution stage owner per item. No dual authority.

## 6) If we do only 3 things now

1. Lock the `tech-lead` -> `execution-lead` intake/ack contract as required schema and enforce hard accept/reject behavior.
2. Write the execution defect taxonomy and owner-routing rules (prep defect vs execution defect vs decision block) and make it mandatory in reports.
3. Run shadow-mode parity against `architect-opencode` before cutover; do not deprecate on theory alone.

These three controls prevent the highest-probability failure modes: boundary collapse, blame loops, and migration regression.
