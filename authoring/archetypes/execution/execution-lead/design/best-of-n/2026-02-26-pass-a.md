# Best-of-N Design Review -- Pass A (Execution Leader)

**Date**: 2026-02-26
**Perspective**: A (full-stack recommendation)

## Executive position

The correct archetype identity is `execution-lead` (display: **Execution Lead -- Build Commander**).

Role analogy: the operations commander after mission planning is complete. `tech-lead` is pre-mission planner/integrator; `execution-lead` commands live execution under time pressure, enforces stage gates, and owns whether work is actually done.

I am strongly in favor of a hard stage split:

`shaper -> tech-lead -> execution-lead -> decision owner (+ upstream visibility)`

`architect-opencode` should move out of stage ownership and become transitional orchestration glue only while migration is incomplete.

Direct answers to focus questions:

1. **Role analogy/name**: keep archetype id `execution-lead`; analogy is operations/build commander.
2. **Where test implementation belongs**: execution stage, not technical preparation.
3. **Clean split**: `tech-lead` owns execution-readiness package quality; `execution-lead` owns test-first implementation and independent validation closure.
4. **Delegation model**: `execution-lead` is leader; `test-implementer`, `implement-plan`, `validate-plan` are members returning artifacts only to leader.

## Recommended V1 article set (filenames + rationale)

### Truth articles

1. `truth/stage-handoffs-need-single-runtime-owner.md`
   - Execution cannot have dual command. Single owner is required once coding begins.

2. `truth/red-before-green-proves-test-obligation.md`
   - TDD red phase is structural proof (tests must fail before implementation), grounding test-first execution order.

3. `truth/build-work-discovers-risk-late-and-fast.md`
   - Live implementation reveals hidden interdependencies quickly; stage owner must absorb and route them without boundary drift.

4. `truth/self-approval-is-a-weak-completion-signal.md`
   - Builders validating their own completion is insufficient; independent validation is needed before stage exit.

5. `truth/fixed-time-execution-requires-active-scope-cuts.md`
   - Fixed time implies ongoing must-have/nice-to-have cuts during build, not only during shaping/prep.

### Ethos articles

1. `ethos/identity.md`
   - I am execution stage owner, not product shaper, not technical-preparation lead, not an individual implementer.

2. `ethos/tenets.md`
   - Test-first is non-negotiable.
   - Completion means validated behavior, not activity.
   - Boundary-respecting escalation over local patching of upstream defects.
   - Scope stewardship under appetite during execution.

3. `ethos/principles.md`
   - Gate by evidence; no stage exit on confidence language.
   - Member artifacts return to leader.
   - Keep one execution narrative and one stage-complete report.

### Doctrine articles

1. `doctrine/process.md`
   - Ordered flow: intake -> test implementation -> code implementation -> validation -> close or loop.

2. `doctrine/orchestration.md`
   - Delegate set, dependency rules, retry/escalation rules, quality gate behavior.

3. `doctrine/team-contract.md`
   - Explicit member/leader boundaries and non-overlap with `tech-lead`.

4. `doctrine/pipeline.md`
   - Stage placement and return path for upstream defects.

5. `doctrine/output-contract.md`
   - Stage-complete artifact schema (commits, test status, validation report, unresolved decisions).

6. `doctrine/handoff-contract.md`
   - Contract for intake (`tech-lead -> execution-lead`) and completion (`execution-lead -> decision owner + upstream`).

## Explicit therefore-chains

1. Build-stage ownership ambiguity causes conflicting direction under pressure -> therefore execution needs one accountable runtime owner -> therefore only `execution-lead` can publish stage status and stage-complete output.

2. Red phase proves tests can fail for wrong behavior -> therefore tests are proof obligations before code changes -> therefore `execution-lead` must run `test-implementer` before `implement-plan` for each planned phase group.

3. Implementation always discovers unexpected coupling during real code contact -> therefore execution must have explicit defect-routing discipline -> therefore `execution-lead` routes design/spec/prep defects upstream instead of rewriting upstream artifacts locally.

4. Self-attested completion is vulnerable to blind spots -> therefore independent validation is required for trustworthy closure -> therefore `validate-plan` is mandatory and stage exit is blocked on unresolved critical validation findings.

5. Fixed-time delivery only survives with continuous trade-offs -> therefore scope cuts are execution-time obligations, not prep-time leftovers -> therefore `execution-lead` maintains must-have/nice-to-have state during execution and defers nice-to-haves when needed.

6. Teams compose through explicit contracts, not informal expectations -> therefore handoff schemas must be explicit and acknowledged -> therefore intake and completion handoffs require receipt, sufficiency verdict, blockers, and ownership transition fields.

## Team topology and handoff direction rules

### Topology

- Role type: team leader + stage owner.
- Parent leader: `tech-lead`.
- Member delegates:
  - `test-implementer`
  - `implement-plan`
  - `validate-plan`

### Direction rules

1. Member outputs return to `execution-lead` only.
2. Members do not hand off directly across stage boundary.
3. `execution-lead` is the only publisher of execution-stage completion status.
4. Upstream defect discoveries are routed by `execution-lead` to `tech-lead` (or `shaper` via `tech-lead` if framing defect).
5. Stage exit artifact goes from `execution-lead` to decision owner, with copy to `tech-lead` for closed-loop learning.

## Interim and target handoff contracts

### Interim contract (migration period)

During migration, `architect-opencode` may still be user-facing entrypoint for end-to-end requests. Interim routing should be:

`tech-lead -> execution-lead` for stage ownership, and `architect-opencode` as optional top-level coordinator only.

Required intake payload (`tech-lead -> execution-lead`):

1. active item/workspace path
2. shaped artifact path
3. enriched spec path
4. research/design/test-spec/plan paths
5. must-have vs nice-to-have declarations
6. unresolved decisions and accepted risks
7. readiness assertion from technical-preparation

Required intake acknowledgment (`execution-lead`):

1. `receipt_confirmed`
2. `sufficient_for_execution`
3. `blocking_gaps[]`
4. `execution_start_strategy` (test-first ordering summary)

### Target contract (steady state)

`tech-lead -> execution-lead` is canonical; `architect-opencode` no longer owns execution stage.

Stage-complete payload (`execution-lead -> decision owner + tech-lead`):

1. commit set mapped to plan phases
2. test implementation report
3. implementation report
4. validation report with requirement/plan trace
5. unresolved defects/deferred nice-to-haves (explicit `none` when empty)
6. recommended next decision set (ship, iterate, reshape)

Completion acknowledgment (receiver side):

1. `receipt_confirmed`
2. `accepted_as_stage_complete`
3. `follow_up_required[]` (if any)

## Required updates to `tech-lead` doctrine files

Update these files to remove execution-owner ambiguity and point to `execution-lead`.

1. `framework/archetypes/technical-preparation/tech-lead/doctrine/process.md`
   - Step 6: replace handoff target `architect-opencode` with `execution-lead`.
   - Rename acknowledgment semantics around execution readiness for new receiver.

2. `framework/archetypes/technical-preparation/tech-lead/doctrine/pipeline.md`
   - Replace pipeline line with `shaper -> tech-lead -> execution-lead`.
   - Remove interim execution-ownership claim from `architect-opencode`.

3. `framework/archetypes/technical-preparation/tech-lead/doctrine/team-contract.md`
   - Replace member line naming `architect-opencode` as downstream owner.
   - Add explicit clause: downstream stage owner is `execution-lead`.

4. `framework/archetypes/technical-preparation/tech-lead/doctrine/handoff-contract.md`
   - Rewrite contract parties to `tech-lead` and `execution-lead`.
   - Keep acknowledgment fields but align naming to execution-stage intake semantics.

5. `framework/archetypes/technical-preparation/tech-lead/doctrine/output-contract.md`
   - Keep package schema but adjust handoff record target and completion language to `execution-lead`.

6. `framework/archetypes/technical-preparation/tech-lead/doctrine/orchestration.md`
   - Update downstream handoff references and verbatim block to match new boundary.

7. `framework/archetypes/technical-preparation/tech-lead/references/template.md`
   - Replace interim handoff target with `execution-lead` and update field labels accordingly.

## Risks / anti-patterns and mitigations

1. **Dual ownership (`architect-opencode` + `execution-lead`)**
   - Mitigation: one canonical stage owner field; doctrine updates above become mandatory before rollout.

2. **Test implementation pulled upstream into technical preparation**
   - Mitigation: enforce boundary: technical prep outputs test specs and plan only; executable tests are execution-stage artifacts.

3. **Execution lead becomes taskmaster (violating Shape Up autonomy)**
   - Mitigation: delegate projects/phases and quality gates, not task scripts; keep anti-identity explicit.

4. **Validation degraded into optional check**
   - Mitigation: stage-exit gate requires `validate-plan` report; no bypass except explicit decision-owner override.

5. **Silent upstream patching by execution team**
   - Mitigation: mandatory defect routing path and explicit defect record in stage report.

6. **Scope drift during end-of-cycle pressure**
   - Mitigation: must-have/nice-to-have ledger maintained by `execution-lead`; only must-haves block closure.

7. **Contract drift across teams**
   - Mitigation: shared schema fields in doctrine `handoff-contract.md` and reference templates; explicit `none` for empty sets.

## Open questions

1. During migration, should `architect-opencode` be allowed to trigger execution work directly, or must all execution begin through `execution-lead` intake only?
2. Should `execution-lead` own PR packaging in V1, or leave packaging as an external/optional utility until stage split stabilizes?
3. What exact severity threshold in validation findings blocks stage exit vs allows decision-owner acceptance?
4. Do we require machine-readable handoff logs now, or keep markdown contracts until harness topology enforcement lands?
5. Should the execution team include a dedicated commit/packaging member later, or keep that responsibility inside `execution-lead` doctrine?
