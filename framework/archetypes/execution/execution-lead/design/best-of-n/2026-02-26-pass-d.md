# Best-of-N Pass D -- Runtime Operations (Execution Stage)

**Date**: 2026-02-26
**Perspective**: D (runtime orchestration mechanics)
**Archetype**: `execution-lead`

---

## Source Grounding Used

Required sources read for this pass:

- Shape Up full corpus (`thoughts/research/Shape-Up-Book/markdown/pages/002-024`)
- `~/.claude/skills/architect-opencode/SKILL.md`
- `~/.claude/skills/validate-plan/SKILL.md`
- `framework/archetypes/development/test-implementer/doctrine/*.md`
- `framework/archetypes/development/implement-plan/doctrine/*.md`
- `framework/archetypes/technical-preparation/tech-lead/doctrine/handoff-contract.md`
- `framework/archetypes/technical-preparation/tech-lead/doctrine/process.md`
- `framework/archetypes/technical-preparation/tech-lead/doctrine/orchestration.md`
- `docs/framework/ARCHETYPE_WORKFLOW.md`
- `docs/framework/VOCABULARY.md`

---

## Runtime Truths That Matter for Execution Doctrine

1. Shape Up is explicit that shaping should remove rabbit holes before build commitment, and build teams should own execution inside fixed-time boundaries.
2. Shape Up also requires a circuit breaker: no automatic extension when timebox assumptions fail.
3. `architect-opencode` already proves an OpenCode-native command pattern: `Task(subagent_type="general")` plus skill-first delegation prompts and post-return quality gates.
4. `test-implementer` and `implement-plan` already encode phase-local ownership boundaries and parallel-safe conditions.
5. `validate-plan` is itself an orchestrator with parallel clone validation; execution-stage leader should treat validation as a mandatory stage gate, not optional polish.
6. Current `tech-lead` handoff contract still names `architect-opencode` as interim execution owner; this must be updated to prevent boundary drift now that `execution-lead` exists.

Therefore, the execution doctrine should optimize for:

- explicit dependency-aware delegation order,
- hard quality gates between member returns,
- bounded retries with escalation,
- objective evidence bundle for stage completion.

---

## V1 Doctrine Blueprint (Execution-Lead)

## Stage Identity

`execution-lead` is the execution stage owner and team leader. Members are:

- `test-implementer`
- `implement-plan`
- `validate-plan`

Members produce bounded artifacts and return to `execution-lead`. Only `execution-lead` publishes stage completion.

## Delegation Order (Concrete)

1. **Intake and acknowledgment**
   - Receive execution package from `tech-lead`.
   - Validate required fields present: plan path, test spec path(s), design references, unresolved decisions, accepted risks.
   - Return acknowledgment contract (`receipt_confirmed`, `sufficiency_for_execution`, `blocking_gaps[]`, `first_execution_step`).

2. **Preflight gate (execution readiness)**
   - Verify plan includes explicit phase ownership split:
     - test phases -> `test-implementer`
     - implementation phases -> `implement-plan`
   - Verify `test_spec_source` exists and is readable.
   - Verify unresolved decisions are either closed or explicitly accepted for execution.

3. **Delegate `/test-implementer` first**
   - Delegate by plan path.
   - Require return fields: files, test count, compile/parse status, commit(s), phase checkboxes updated.
   - Gate: tests implemented from spec and committed separately from implementation code.

4. **Delegate `/implement-plan` second**
   - Only after test gate passes.
   - Delegate implementation phases according to plan execution graph.
   - Require return fields: per-phase commit hash, verification command outputs, plan checkbox updates, propagated issues list.
   - Gate: tests pass, phase commitments satisfied, no unauthorized test rewrites.

5. **Delegate `/validate-plan` third**
   - Validation runs after implementation gate passes.
   - Require validation to check plan + source requirements + test spec traceability.
   - Gate: no critical failures, explicit status for each phase and each source requirement.

6. **Publish stage completion or escalation**
   - If validate gate passes: publish completion package.
   - If validate gate fails: re-enter delegated fix loop (or escalate if retry cap exceeded / plan defect detected).

## Why this order is required

It preserves test-first execution, keeps proof obligations fixed before implementation, and matches both development archetype contracts and Shape Up risk control (unknowns and scope decisions resolved before final downhill execution).

---

## Parallelism and Serialization Rules

## Serialization (must be sequential)

1. Intake acknowledgment -> preflight gate
2. Preflight gate -> test implementation start
3. Test implementation completion gate -> implementation start
4. Implementation completion gate -> final validation start
5. Final validation result -> stage completion publish

Reason: each step changes the validity of downstream work. Skipping these dependencies creates false progress.

## Parallelism (allowed)

1. **Inside test implementation**: parallel only for independent test phases with no file overlap and no shared fixture contention.
2. **Inside implementation**: parallel only when plan execution graph marks phases as parallel-safe and file overlap is absent.
3. **Inside validation**: phase validation can run in parallel by `validate-plan-clone` because validation is read-heavy.
4. **Cross-section execution**: parallel only if sections are independent and dependency edges are explicit in plan contract.

## Parallelism rejection rules

Do not parallelize when:

- phases touch same files or same mutable shared state,
- one phase depends on new API/behavior from another,
- unresolved design/test issues exist in upstream phase,
- merge conflict probability is high enough to erase throughput gains.

---

## Retry and Escalation Rules

## Retry budget

- Max two correction retries per failed gate (aligns with current `tech-lead` doctrine and system consistency).
- Retry requests must include:
  - failed gate name,
  - specific defect observed,
  - required correction,
  - unchanged acceptance criteria.

## Escalation triggers (immediate)

1. Missing or contradictory upstream package fields that block safe execution.
2. Plan-design-test contradiction that cannot be resolved by implementation adjustments.
3. Any required decision that changes scope/appetite risk profile.
4. Validation finds source requirement gaps that imply preparation-stage defect.

## Escalation routing

- **Preparation defect** -> escalate to `tech-lead` with contract-specific defect list.
- **Strategic/scope tradeoff needed** -> escalate to decision owner with options + impact.
- **Execution defect only** -> loop back to member delegate within retry budget.

## Escalation payload contract

1. blocked gate
2. blocker class (`package-defect` | `plan-defect` | `implementation-defect` | `decision-needed`)
3. concrete evidence references (file/commit/report)
4. appetite/schedule impact
5. recommended options (A/B) and preferred path

---

## Execution Evidence and Completion Contract

`execution-lead` should not declare completion from narrative confidence. Completion requires an evidence bundle.

## Required evidence bundle

1. Intake acknowledgment record
2. Test implementation report
   - spec coverage statement
   - test file list
   - test commit hashes
3. Implementation report
   - per-phase commits
   - verification command results
   - plan checkbox deltas
4. Validation report
   - phase pass/fail
   - source requirement traceability
   - critical/high issues list
5. Exception ledger
   - propagated issues and their destination (`tech-lead` or decision owner)

## Stage completion contract (minimum fields)

1. `execution_status`: `complete` | `blocked`
2. `plan_path`
3. `test_spec_path`
4. `test_commit_hashes[]`
5. `implementation_commit_hashes[]`
6. `validation_report_path`
7. `requirement_coverage`: `full` | `partial`
8. `open_issues[]` (explicit `none` if empty)
9. `escalations[]` (explicit `none` if empty)
10. `recommended_next_action`

Without these fields, stage completion is not valid.

---

## Explicit Recommendation: Should Execution Start With Test Implementation?

Yes. Execution should start with `test-implementer` before `implement-plan` for normal section work.

Rationale:

1. Existing development archetypes already define tests as proof obligations and implementation as satisfying those obligations.
2. It prevents silent contract drift by locking expected behavior before code changes.
3. It gives `validate-plan` a stable oracle chain: requirement -> test spec -> test code -> implementation.
4. It matches Shape Up's risk posture: solve uncertainty early, then execute downhill.

Exception policy:

- Only bypass test-first order when the plan marks a phase `test_not_applicable` with explicit reason (e.g., pure infrastructure migration with externally validated constraints), and this exception is acknowledged by `execution-lead` during preflight.

## Plan contract representation required

The implementation plan contract should include explicit ownership and order metadata:

1. `phase_type`: `test` | `implementation` | `validation-support`
2. `owner_role`: `test-implementer` | `implement-plan` | `execution-lead`
3. `depends_on[]`: phase ids
4. `parallel_safe`: true|false
5. `blocking_gate`: named gate required before this phase begins
6. `commit_intent`: expected commit message seed
7. `proof_artifact`: test/report/output expected from phase

This converts test-first from convention into contract.

---

## Upstream `tech-lead` Doctrine Updates Required

Current `tech-lead` doctrine still names `architect-opencode` as interim execution owner. Update required for boundary coherence.

## Required edits

1. **`doctrine/handoff-contract.md`**
   - Replace execution target from `architect-opencode` -> `execution-lead`.
   - Keep acknowledgment fields, but set `first_execution_step` expectation to test-implementation start unless exception declared.
   - Add required payload field: `plan_contract_has_phase_ownership` (true|false).

2. **`doctrine/process.md` Step 6**
   - Change handoff destination and language to execution stage owner.
   - Add readiness gate that plan encodes test-first phase ordering and ownership metadata.

3. **`doctrine/pipeline.md`**
   - Replace interim pipeline edge:
     - from `tech-lead -> architect-opencode`
     - to `tech-lead -> execution-lead`

4. **`doctrine/output-contract.md`**
   - Add package field requiring execution-order declaration (`test -> implement -> validate`).
   - Add package field requiring exception flags for any test-first bypass.

5. **`doctrine/orchestration.md`**
   - Add explicit quality gate: no downstream handoff if plan lacks owner-role assignment per phase.

These updates are necessary to maintain single-owner stage boundaries and prevent runtime ambiguity.

---

## Practical OpenCode Choreography Notes (Operational)

1. Use one delegated `Task(subagent_type="general")` per command archetype invocation, with skill-first prompt pattern preserved.
2. Use parallel delegation only within declared independent scopes/phases, not across contract gates.
3. Read and evaluate returned artifacts after each delegation before starting downstream delegation.
4. Keep retry feedback defect-specific; never "re-run and hope."
5. Treat validation as completion gate, not advisory review.

This yields a doctrine that is executable in OpenCode today and consistent with Renkei stage-boundary accountability.
